// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// C++ from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


#include "Robot.h"
#include "RobotMap.h"

#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/core/core.hpp>

//
//#include "Subsystems/UltrasonicSensor.h"

// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION
std::shared_ptr<DriveTrain> Robot::driveTrain;
std::unique_ptr<OI> Robot::oi;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=INITIALIZATION

std::shared_ptr<UltrasonicSensor> Robot::distanceSensor;
std::shared_ptr<Gimbal> Robot::gimbal;

static void VisionThread() {
	cs::UsbCamera camera = CameraServer::GetInstance()->StartAutomaticCapture();

	cs::CvSink cvSink = CameraServer::GetInstance()->GetVideo();
	cs::CvSource outputStreamStd = CameraServer::GetInstance()->PutVideo("Autonomous Cam", 640, 480);

	system("v4l2-ctl -c exposure_auto=1,white_balance_temperature_auto=0");

	cv::Mat source = cv::Mat(160, 120, CV_8UC3);
	cv::Mat output = cv::Mat(160, 120, CV_8UC3);
	cv::Mat temp = cv::Mat(160, 120, CV_8UC3);

	while (true) {
		if (vtLookForLights) {
			system("v4l2-ctl -c exposure_absolute=0");
		}
		while (vtLookForLights) {
			cvSink.GrabFrame(source);

			cv::cvtColor(source, output, CV_BGR2GRAY);
			cv::cvtColor(output, output, CV_GRAY2BGR);

			cv::blur(source, temp, cv::Size(5, 5));

			cv::cvtColor(temp, temp, CV_BGR2HLS);

			cv::Mat hlsChannels[3];
			cv::split(temp, hlsChannels);

			cv::threshold(hlsChannels[1], hlsChannels[1], 225, 255, 0);

			std::vector<std::vector<cv::Point>> contours;
			cv::findContours(hlsChannels[1], contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);

			if (contours.size() > 0) {
				double totalBlue = 0;
				double totalRed = 0;

				double sizes[contours.size()];
				cv::Point centers[contours.size()];

				int mostLeft = -1;
				int mostRight = -1;

				for (unsigned int i = 0; i < contours.size(); i++) {
					cv::Moments moments = cv::moments(contours[i]);

					if (moments.m00 > 1) {
						sizes[i] = moments.m00;
						centers[i] = cv::Point(moments.m10/moments.m00, moments.m01/moments.m00);

						int hue, sat;
						if (contours[i][0].x != 0 && contours[i][0].y != 0) {
							hue = hlsChannels[0].at<uchar>(contours[i][0].y, contours[i][0].x);
							sat = hlsChannels[2].at<uchar>(contours[i][0].y, contours[i][0].x);
						}
						else {
							hue = hlsChannels[0].at<uchar>(contours[i][1].y, contours[i][1].x);
							sat = hlsChannels[2].at<uchar>(contours[i][1].y, contours[i][1].x);
						}

						// blue
						if (vtLookForBlue && hue > 70 && hue < 130 && sat > 150) {
							totalBlue += moments.m00;

							if (mostLeft == -1 && mostRight == -1) {
								mostLeft = i;
								mostRight = i;
							}
							else if (centers[i].x < centers[mostLeft].x) {
								mostLeft = i;
							}
							else if (centers[i].x > centers[mostRight].x) {
								mostRight = i;
							}

							cv::drawContours(output, contours, i, cv::Scalar(255, 0, 0), 1);
						}
						// red
						else if (!vtLookForBlue && (hue > 155 || hue < 35) && sat > 150) {
							totalRed += moments.m00;

							if (mostLeft == -1 && mostRight == -1) {
								mostLeft = i;
								mostRight = i;
							}
							else if (centers[i].x < centers[mostLeft].x) {
								mostLeft = i;
							}
							else if (centers[i].x > centers[mostRight].x) {
								mostRight = i;
							}

							cv::drawContours(output, contours, i, cv::Scalar(0, 0, 255), 1);
						}
					}
				}

				vtFound = true;
				vtOffsetX = ((float)(centers[mostLeft].x + centers[mostRight].x) / 2 - source.cols) / (float)(source.cols * 0.5);
				vtOffsetY = ((float)(centers[mostLeft].y + centers[mostRight].y) / 2 - source.rows) / (float)(source.rows * 0.5);
				vtMostIsBlue = (totalBlue > totalRed) ? true : false;

				cv::line(output, centers[mostLeft], centers[mostRight], cv::Scalar(0, 255, 0), 2);
			}
			else {
				vtFound = false;
			}

			outputStreamStd.PutFrame(output);
		}



		if (!vtLookForLights) {
			system("v4l2-ctl -c exposure_absolute=156");
		}
		while (!vtLookForLights) {
			cvSink.GrabFrame(source);

			cv::cvtColor(source, output, CV_BGR2GRAY);
			cv::cvtColor(output, output, CV_GRAY2BGR);

			cv::blur(source, temp, cv::Size(5, 5));

			cv::cvtColor(temp, temp, CV_BGR2HSV);

			cv::Mat hsvChannels[3];
			cv::split(temp, hsvChannels);

			cv::inRange(hsvChannels[0], 10, 50, hsvChannels[0]);
			cv::threshold(hsvChannels[1], hsvChannels[1], 70, 255, CV_THRESH_BINARY_INV);
			cv::threshold(hsvChannels[2], hsvChannels[2], 70, 255, CV_THRESH_BINARY_INV);

			temp = hsvChannels[0] - hsvChannels[1] - hsvChannels[2];

			cv::erode(temp, temp, cv::Mat(), cv::Point(-1, -1), 3);
			cv::dilate(temp, temp, cv::Mat(), cv::Point(-1, -1), 6);

			std::vector<std::vector<cv::Point>> contours;
			cv::findContours(temp, contours, CV_RETR_EXTERNAL, CV_CHAIN_APPROX_SIMPLE);

			if (contours.size() > 0) {
				int largest = 0;
				double mass = 0;
				cv::Point center;

				for (unsigned int i = 0; i < contours.size(); i++) {
					cv::Moments moments = cv::moments(contours[i]);

					if (moments.m00 > mass) {
						largest = i;
						mass = moments.m00;
						center = cv::Point(moments.m10/moments.m00, moments.m01/moments.m00);
					}

					cv::drawContours(output, contours, i, cv::Scalar(0, 0, 100), 1);
				}

				if (mass > 500) {
					vtFound = true;
					vtOffsetX = (float)(center.x - source.cols) / (float)(source.cols * 0.5);
					vtOffsetY = (float)(center.y - source.rows) / (float)(source.rows * 0.5);
				}
				else {
					vtFound = false;
				}
				cv::drawContours(output, contours, largest, cv::Scalar(0, 0, 255), 1);
			}
			else {
				vtFound = false;
			}

			outputStreamStd.PutFrame(output);
		}
	}
}

void Robot::RobotInit() {
	RobotMap::init();
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
    driveTrain.reset(new DriveTrain());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTORS
	// This MUST be here. If the OI creates Commands (which it very likely
	// will), constructing it during the construction of CommandBase (from
	// which commands extend), subsystems are not guaranteed to be
	// yet. Thus, their requires() statements may grab null pointers. Bad
	// news. Don't move it.
	oi.reset(new OI());

	// Add commands to Autonomous Sendable Chooser
	// BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS

	CameraServer::GetInstance()->StartAutomaticCapture();
	chooser.AddDefault("Autonomous Command", new AutonomousCommand('l', 'r', 'a', 'c', 'o', 'w'));

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=AUTONOMOUS
	frc::SmartDashboard::PutData("Auto Modes", &chooser);

    distanceSensor.reset(new UltrasonicSensor(0, 0, 0));
    gimbal.reset(new Gimbal(0, 1));

	vtLookForLights = true;
	vtLookForBlue = true;

	vtOffsetX = 0;
	vtOffsetY = 0;

	std::thread visionThread(VisionThread);
	visionThread.detach();
}

/**
 * This function is called when the disabled button is hit.
 * You can use it to reset subsystems before shutting down.
 */
void Robot::DisabledInit(){

}

void Robot::DisabledPeriodic() {
	frc::Scheduler::GetInstance()->Run();
}

void Robot::AutonomousInit() {
	autonomousCommand = chooser.GetSelected();
	if (autonomousCommand != nullptr)
		autonomousCommand->Start();
}

void Robot::AutonomousPeriodic() {
	frc::Scheduler::GetInstance()->Run();
//	RobotMap::driveTrainRobotDrive->ArcadeDrive(visionAngle, visionMovement, true);
}

void Robot::TeleopInit() {
	// This makes sure that the autonomous stops running when
	// teleop starts running. If you want the autonomous to
	// continue until interrupted by another command, remove
	// these lines or comment it out.
	if (autonomousCommand != nullptr)
		autonomousCommand->Cancel();
}

void Robot::TeleopPeriodic() {
	frc::Scheduler::GetInstance()->Run();
	const auto& joystick = oi->getDriverJoystick();
	RobotMap::driveTrainRobotDrive->ArcadeDrive(joystick->GetX(), joystick->GetY(), true);
}

START_ROBOT_CLASS(Robot);

